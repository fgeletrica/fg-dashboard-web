class EletricoResult {
  final double ibA;
  final double caboMm2;
  final int izA;
  final int disjuntorA;
  final double quedaTensaoPct;
  final double limiteQvPct;

  const EletricoResult({
    required this.ibA,
    required this.caboMm2,
    required this.izA,
    required this.disjuntorA,
    required this.quedaTensaoPct,
    required this.limiteQvPct,
  });
}

class EletricoCalc {
  // Tabela conservadora (aprox.) cobre em eletroduto / 2 condutores carregados / 30°C
  static const List<_Amp> _ampacidadeCu = [
    _Amp(1.5, 15),
    _Amp(2.5, 21),
    _Amp(4.0, 28),
    _Amp(6.0, 36),
    _Amp(10.0, 50),
    _Amp(16.0, 68),
    _Amp(25.0, 89),
    _Amp(35.0, 110),
    _Amp(50.0, 140),
    _Amp(70.0, 175),
    _Amp(95.0, 210),
  ];

  static const List<int> _disjuntores = [6, 10, 16, 20, 25, 32, 40, 50, 63, 80, 100, 125, 160, 200];

  static double correnteIb({required double potW, required double tensaoV}) {
    if (tensaoV <= 0) return 0;
    return potW / tensaoV;
  }

  static _Amp _escolherCaboPorCorrente(double ibA) {
    for (final a in _ampacidadeCu) {
      if (a.izA >= ibA) return a;
    }
    return _ampacidadeCu.last;
  }

  static int _escolherDisjuntor({required double ibA, required int izA}) {
    // Regra: In >= Ib e In <= Iz (pra proteger o cabo)
    for (final d in _disjuntores) {
      if (d >= ibA && d <= izA) return d;
    }
    // fallback: não passa do Iz
    final menoresOuIgual = _disjuntores.where((d) => d <= izA).toList();
    if (menoresOuIgual.isNotEmpty) return menoresOuIgual.last;
    return _disjuntores.first;
  }

  static double quedaTensaoPct({
    required double ibA,
    required double distanciaM,
    required double secaoMm2,
    required double tensaoV,
  }) {
    if (tensaoV <= 0 || secaoMm2 <= 0 || distanciaM <= 0) return 0;
    const rho = 0.018; // Ω·mm²/m (aprox. cobre)
    final dv = (2.0 * distanciaM * ibA * rho) / secaoMm2; // monofásico (ida+volta)
    return (dv / tensaoV) * 100.0;
  }

  static EletricoResult dimensionar({
    required double potW,
    required double tensaoV,
    required double distanciaM,
    double limiteQvPct = 4.0,
  }) {
    final ib = correnteIb(potW: potW, tensaoV: tensaoV);

    var amp = _escolherCaboPorCorrente(ib);
    var qv = quedaTensaoPct(ibA: ib, distanciaM: distanciaM, secaoMm2: amp.secaoMm2, tensaoV: tensaoV);

    // Se queda de tensão estourar, sobe seção até atender (mantendo Iz >= Ib)
    if (distanciaM > 0) {
      for (final a in _ampacidadeCu) {
        final qvTry = quedaTensaoPct(ibA: ib, distanciaM: distanciaM, secaoMm2: a.secaoMm2, tensaoV: tensaoV);
        if (qvTry <= limiteQvPct && a.izA >= ib) {
          amp = a;
          qv = qvTry;
          break;
        }
      }
    }

    final disj = _escolherDisjuntor(ibA: ib, izA: amp.izA);

    double r2(double v) => (v * 100).roundToDouble() / 100.0;

    return EletricoResult(
      ibA: r2(ib),
      caboMm2: amp.secaoMm2,
      izA: amp.izA,
      disjuntorA: disj,
      quedaTensaoPct: r2(qv),
      limiteQvPct: limiteQvPct,
    );
  }
}

class _Amp {
  final double secaoMm2;
  final int izA;
  const _Amp(this.secaoMm2, this.izA);
}
