import 'dart:convert';
import 'dart:io';

import 'package:shared_preferences/shared_preferences.dart';
import '../models/industrial_models.dart';

class IndustrialStore {
  static const _kLineStops = 'ind_line_stops_v1';
  static const _kKnowledge = 'ind_knowledge_v1';
  static const _kChecklistRuns = 'ind_checklist_runs_v1';

  static Future<List<String>> _getList(String key) async {
    final sp = await SharedPreferences.getInstance();
    return sp.getStringList(key) ?? <String>[];
  }

  static Future<void> _setList(String key, List<String> v) async {
    final sp = await SharedPreferences.getInstance();
    await sp.setStringList(key, v);
  }

  // ---------- LINHA PAROU ----------
  static Future<List<LineStopReport>> listLineStops({int limit = 200}) async {
    final raw = await _getList(_kLineStops);
    final items = raw.map((e) => LineStopReport.fromJson(e)).toList();
    items.sort((a, b) => b.ts.compareTo(a.ts));
    return items.take(limit).toList();
  }

  static Future<void> addLineStop(LineStopReport r) async {
    final raw = await _getList(_kLineStops);
    raw.add(r.toJson());
    await _setList(_kLineStops, raw);
  }

  static Future<void> deleteLineStop(String id) async {
    final raw = await _getList(_kLineStops);
    raw.removeWhere((e) {
      try {
        final m = jsonDecode(e) as Map<String, dynamic>;
        return (m['id'] ?? '').toString() == id;
      } catch (_) {
        return false;
      }
    });
    await _setList(_kLineStops, raw);
  }

  // ---------- BASE DE CONHECIMENTO ----------
  static Future<List<KnowledgeItem>> listKnowledge({int limit = 500}) async {
    final raw = await _getList(_kKnowledge);
    final items = raw.map((e) => KnowledgeItem.fromMap(jsonDecode(e) as Map<String, dynamic>)).toList();
    items.sort((a, b) => b.ts.compareTo(a.ts));
    return items.take(limit).toList();
  }

  static Future<void> addKnowledge(KnowledgeItem k) async {
    final raw = await _getList(_kKnowledge);
    raw.add(jsonEncode(k.toMap()));
    await _setList(_kKnowledge, raw);
  }

  static Future<void> deleteKnowledge(String id) async {
    final raw = await _getList(_kKnowledge);
    raw.removeWhere((e) {
      try {
        final m = jsonDecode(e) as Map<String, dynamic>;
        return (m['id'] ?? '').toString() == id;
      } catch (_) {
        return false;
      }
    });
    await _setList(_kKnowledge, raw);
  }

  // ---------- CHECKLISTS ----------
  static Future<List<ChecklistRun>> listChecklistRuns({int limit = 300}) async {
    final raw = await _getList(_kChecklistRuns);
    final items = raw.map((e) => ChecklistRun.fromMap(jsonDecode(e) as Map<String, dynamic>)).toList();
    items.sort((a, b) => b.ts.compareTo(a.ts));
    return items.take(limit).toList();
  }

  static Future<void> addChecklistRun(ChecklistRun r) async {
    final raw = await _getList(_kChecklistRuns);
    raw.add(jsonEncode(r.toMap()));
    await _setList(_kChecklistRuns, raw);
  }

  // =========================
  // A+B+D: FILTRO + STATS
  // =========================

  static List<LineStopReport> filterLineStops(
    List<LineStopReport> list, {
    DateTimeRange? range,
    String? shift,
    String query = '',
  }) {
    final q = query.trim().toLowerCase();

    bool inRange(LineStopReport r) {
      if (range == null) return true;
      final dt = DateTime.fromMillisecondsSinceEpoch(r.ts);
      return !dt.isBefore(range.start) && !dt.isAfter(range.end);
    }

    bool inShift(LineStopReport r) {
      if (shift == null || shift.trim().isEmpty || shift == 'ALL') return true;
      return r.shift.trim().toUpperCase() == shift.trim().toUpperCase();
    }

    bool inQuery(LineStopReport r) {
      if (q.isEmpty) return true;
      final hay = '${r.area} ${r.machine} ${r.shift} ${r.symptom} ${r.description} '
              '${r.testsDone.join(' ')} ${r.probableCause} ${r.actionTaken} ${r.prevention} ${r.downtimeMin}'
          .toLowerCase();
      return hay.contains(q);
    }

    return list.where((r) => inRange(r) && inShift(r) && inQuery(r)).toList();
  }

  static int parseDowntimeMin(LineStopReport r) {
    final s = r.downtimeMin.trim().replaceAll(',', '.');
    final v = double.tryParse(s);
    return (v == null) ? 0 : v.round();
  }

  static Map<String, int> downtimeByMachine(List<LineStopReport> list) {
    final m = <String, int>{};
    for (final r in list) {
      final k = r.machine.trim().isEmpty ? 'Sem máquina' : r.machine.trim();
      m[k] = (m[k] ?? 0) + parseDowntimeMin(r);
    }
    return m;
  }

  static Map<String, int> countByMachine(List<LineStopReport> list) {
    final m = <String, int>{};
    for (final r in list) {
      final k = r.machine.trim().isEmpty ? 'Sem máquina' : r.machine.trim();
      m[k] = (m[k] ?? 0) + 1;
    }
    return m;
  }

  static Map<String, int> countByCause(List<LineStopReport> list) {
    final m = <String, int>{};
    for (final r in list) {
      final k = r.probableCause.trim().isEmpty ? 'Sem causa' : r.probableCause.trim();
      m[k] = (m[k] ?? 0) + 1;
    }
    return m;
  }

  static String topKey(Map<String, int> m) {
    if (m.isEmpty) return '—';
    final entries = m.entries.toList()..sort((a, b) => b.value.compareTo(a.value));
    return entries.first.key;
  }

  static int sumDowntime(List<LineStopReport> list) {
    var s = 0;
    for (final r in list) {
      s += parseDowntimeMin(r);
    }
    return s;
  }

  // =========================
  // C: EXPORT CSV (salva em Downloads)
  // =========================
  static String _csvEscape(String v) {
    var s = v.replaceAll('\r', ' ').replaceAll('\n', ' ').trim();
    if (s.contains('"')) s = s.replaceAll('"', '""');
    // sempre aspas pra evitar dor de cabeça
    return '"$s"';
  }

  static Future<Directory> _defaultExportDir() async {
    // Linux/Windows/macOS: tenta ~/Downloads
    final home = Platform.environment['HOME'] ?? Platform.environment['USERPROFILE'];
    if (home != null && home.trim().isNotEmpty) {
      final d = Directory('$home/Downloads');
      if (await d.exists()) return d;
      // fallback: cria
      await d.create(recursive: true);
      return d;
    }
    // fallback geral: diretório atual
    return Directory.current;
  }

  static Future<File> exportLineStopsCsv(
    List<LineStopReport> list, {
    required String filenamePrefix,
  }) async {
    final dir = await _defaultExportDir();
    final stamp = DateTime.now().toIso8601String().replaceAll(':', '').replaceAll('-', '').split('.').first;
    final file = File('${dir.path}/${filenamePrefix}_$stamp.csv');

    // header
    final b = StringBuffer();
    b.writeln('id;timestamp;data;area;maquina;turno;sintoma;descricao;testes;causa_provavel;acao_tomada;tempo_parado_min;prevencao');

    for (final r in list) {
      final dt = DateTime.fromMillisecondsSinceEpoch(r.ts);
      final data = dt.toString().replaceFirst('T', ' ').substring(0, 19);
      final testes = r.testsDone.join(' | ');
      b.writeln([
        _csvEscape(r.id),
        _csvEscape(r.ts.toString()),
        _csvEscape(data),
        _csvEscape(r.area),
        _csvEscape(r.machine),
        _csvEscape(r.shift),
        _csvEscape(r.symptom),
        _csvEscape(r.description),
        _csvEscape(testes),
        _csvEscape(r.probableCause),
        _csvEscape(r.actionTaken),
        _csvEscape(r.downtimeMin),
        _csvEscape(r.prevention),
      ].join(';'));
    }

    await file.writeAsString(b.toString(), flush: true);
    return file;
  }
}
